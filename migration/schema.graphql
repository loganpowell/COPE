#   
#                                                    
#    e88~~8e  888-~88e 888  888 888-~88e-~88e  d88~\ 
#   d888  88b 888  888 888  888 888  888  888 C888   
#   8888__888 888  888 888  888 888  888  888  Y88b  
#   Y888    , 888  888 888  888 888  888  888   888D 
#    "88___/  888  888 "88_-888 888  888  888 \_88P  
#                                                    
#   


enum NodeType {
    # --- ðŸ”» REQUIRED: DO NOT REPLACE/REMOVE ðŸ”» ---
    R_ACCOUNT
    # --- ðŸ”º REQUIRED: DO NOT REPLACE/REMOVE ðŸ”º ---


    # Human #####################################
    H_AUTHOR
    H_TEAM

    # Geographic Hierarchy #######################
    # summary level = 040 (State)
    # GEO_01 # Alabama
    # ...

    # Thing ######################################
    A_ARTICLE
    A_PAGE # findable by router/deeplink
    A_APPLICATION
    A_GEM
    A_COURSE

    # Survey
    S_ACS
    S_DECENNIAL
    S_CBP

    # Vintage
    V_1990
    V_2000
    V_2010
    V_2020

    # Collections/Groupings/branches #############
    C_COURSES
    C_SERIES # Ordered/linked list
    C_LIST # Ordered/sortable

}


enum Predicate {
    # Human to Asset
    AUTHORED
    # linked list/ordered
    HAS_NEXT
    HAS_PREVIOUS
    # Group to Subgroup
    HAS_PART
    # Node to Node: Hierarchical
    HAS_CHILD
}

enum AssetType {
    # Documentation #############################
    """
    A [description](http://spec.graphql.org/June2018/#sec-Descriptions), 
    here in parentheses, is `markdown` friendly!
    """
    DEPRECATED @deprecated(reason: "the reason is _also_ `markdown` friendly!") 

    # Multimedia Assets ##############################
    A_IMAGE
    A_OG_IMAGE # open graph (https://ogp.me/#metadata)
    A_OG_AUDIO
    A_OG_VIDEO
    A_VIDEO
    A_AUDIO

    # Text (Markdown enabled) #######################
    # open graph âš  needs client-side validation (custom UI) for optimal/max char length
                        # optimal   | max
    T_OG_TITLE          # 55        | 95
    T_OG_DESCRIPTION    # 55        | 200
    T_OG_TYPE
    T_LEDE
    T_BODY
    
    # Meta: each tag must be a separate resource-type in order for it to be able to be searched by
    M_DATA
    M_MAP
    M_VIZ
    M_API

    # Files ######################################
    F_IMAGE
    F_AUDIO
    F_VIDEO
    F_PDF
    F_KML
    F_SHP
    F_CSV
}

#   
#                                       d8          
#     /~~~8e   d88~\  d88~\  e88~~8e  _d88__  d88~\ 
#         88b C888   C888   d888  88b  888   C888   
#    e88~-888  Y88b   Y88b  8888__888  888    Y88b  
#   C888  888   888D   888D Y888    ,  888     888D 
#    "88_-888 \_88P  \_88P   "88___/   "88_/ \_88P  
#                                                   
#   

interface Resource {
    id              : ID!
    node_id         : ID!
    createdAt       : AWSDateTime!
    updatedAt       : AWSDateTime!
    type            : AssetType!
    name            : String!
    index           : Int
    owner           : String
    content         : String
    editors         : [ String ]
}

# Assets are sub-atomic, i.e., they are not - by themselves
# - useful, but rather are combined into a Node, which is.
#   Nodes are the atomic unit of the system. If an Asset
#   (e.g., an image of a person) is needed for a different
#   use case than the Node that holds it (e.g., Node:Bio =
#   [ image, name, contact ]), then the Asset should be
#   copied to a new Node (e.g., Node:Author = [ image, name,
#   specialization_tags ])
type Asset implements Resource 
    # secure Assets by Node lens
    @model (queries: null)
    @auth (rules: [
        { allow: owner,                                        ownerField: "owner" }, #   identityClaim: "email"   },
        { allow: owner,  operations: [ read, update, delete ], ownerField: "editors" },
        { allow: groups,                       groups: ["Admins", "Editors"]                    },
        { allow: groups, operations: [ read ], groups: ["Viewers"]                              },
        { allow: public, operations: [ read ], provider: iam                                    }
    ])
    @key ( 
        name: "Assets_by_node",
        fields: ["nodeID"],
        #queryField: "assetsByNode"
    )
{
    id              : ID!
    nodeID         : ID!
    createdAt       : AWSDateTime!
    updatedAt       : AWSDateTime!
    type            : AssetType!
    name            : String!
    index           : Int
    owner           : String
    content         : String
    editors         : [ String ]
}

# Change group addition rules to be subordinate inclusive. E.g., 
# Admins = Admins + Editors + Viewers
# SuperAdmins = SuperAdmins + Admins + Editors + Viewers
enum Publicity {
    PRIVATE @auth (rules: [
        { allow: groups,                       groups: ["SuperAdmins"] },
    ])
    DRAFT @auth (rules: [
        { allow: groups, operations: [ read, update ]  groups: ["Admins", "Editors"]  },
    ])
    PUBLIC @auth (rules: [
        { allow: groups,                       groups: ["Admins", "Editors"]  },
        { allow: groups, operations: [ read ], groups: ["Viewers"]            },
        { allow: public, operations: [ read ]                                 }
    ])
    MOVED @auth (rules: [
        { allow: groups, operations: [ read, update, delete ], groups: ["Admins" ] }
        { allow: groups, operations: [ read ], groups: ["Viewers", "Editors"]            },
        { allow: public, operations: [ read ]                                 } 
    ])
    DELETED @auth (rules: [
        { allow: groups, operations: [ read, delete ], groups: ["SuperAdmins", "Admins"]            },
    ])
}

# TODO: enable filtering the object from the subjects of object as to not retrieve self for the same (Acyclical graph)
#  
#                          888                  
#  888-~88e  e88~-_   e88~\888  e88~~8e   d88~\ 
#  888  888 d888   i d888  888 d888  88b C888   
#  888  888 8888   | 8888  888 8888__888  Y88b  
#  888  888 Y888   ' Y888  888 Y888    ,   888D 
#  888  888  "88_-~   "88_/888  "88___/  \_88P  
#                                               
#  
# NOTES:
# https://docs.amplify.aws/cli/graphql-transformer/key#designing-data-models-using-key
# https://www.alexdebrie.com/posts/dynamodb-one-to-many/#composite-primary-key--the-query-api-action
# https://docs.amplify.aws/cli/graphql-transformer/auth#field-level-authorization
#
# Role        | Create | Read  | Update | Delete 
# ----------  | :---:  | :---: | :---:  | :---:
# SuperAdmins | 3      | 3     | 3      | 3
# Admins      | 3      | 3     | 3      | 3
# SuperAdmins | 3      | 3     | 3      | 3
# SuperAdmins | 3      | 3     | 3      | 3
# SuperAdmins | 3      | 3     | 3      | 3
# SuperAdmins | 3      | 3     | 3      | 3
# SuperAdmins | 3      | 3     | 3      | 3
# SuperAdmins | 3      | 3     | 3      | 3
# 
type Node
    @model
    @auth (rules: [
        # groups (Cognito User Pools)
        { allow: groups,                                groups: ["Analytics"] }
        { allow: groups,                                groups: ["Admins"]  },
        { allow: groups, operations: [ read, update ],  groups: ["Writers"] }
        # individuals
        { allow: owner,                                 ownerField: "owner" }, # identityClaim: "email" },
        { allow: owner,  operations: [ read ],          ownerField: "readers" }
        { allow: owner,  operations: [ read, update ],  ownerField: "writers" }
        # assigned groups
        { allow: groups, operations: [ read ],          groupsField: "readerGroups" }
        { allow: groups, operations: [ read, update ],  groupsField: "writerGroups" }
    ])
    # handles searching by publicity | publicity & type | publicity & type & createdAt
    @key (
        name: "Nodes_by_publicity_type_createdAt",
        fields: ["publicity", "type", "createdAt"],
        queryField: "nodesByPublicityType"
    )
    # handles searching by owner | owner & publicity | owner & publicity & createdAt
    @key (
        name: "Nodes_by_owner_publicity_createdAt",
        fields: ["owner", "publicity", "createdAt"],
        queryField: "nodesByOwnerPublicity"
    )
    # handles searching by owner | owner & type | owner & type & createdAt
    @key (
        name: "Nodes_by_owner_type_createdAt",
        fields: ["owner", "type", "createdAt"],
        queryField: "nodesByOwnerType"
    )
{
    id              : ID!
    name            : String!       @auth (rules: [
        { allow: owner, operations: [ create, read, delete ] }
    ])
    publicity       : Publicity!
    type            : NodeType!
    createdAt       : AWSDateTime!
    updatedAt       : AWSDateTime!                  # automatically associated
    owner           : String
    readers         : [String]
    writers         : [String]

    assets          : [ Asset ]     @connection (keyName: "Assets_by_node", fields: ["id"])
    # get objects of this node
    objects         : [ Edge ]      @connection (keyName: "Objects_by_subject", fields: ["id"])
    # get subjects of this node
    subjects        : [ Edge ]      @connection (keyName: "Subjects_by_object", fields: ["id"])
}

#   
#                   888       /                  
#    e88~~8e   e88~\888 e88~88e  e88~~8e   d88~\ 
#   d888  88b d888  888 888 888 d888  88b C888   
#   8888__888 8888  888 "88_88" 8888__888  Y88b  
#   Y888    , Y888  888  /      Y888    ,   888D 
#    "88___/   "88_/888 Cb       "88___/  \_88P  
#                        Y8""8D                  
#   
type Edge 
    @model
    @auth (rules: [
        { allow: owner,                         ownerField: "owner",    identityClaim: "email" },

        # move to Enum security
        { allow: groups,                        groups: ["Admins", "Editors"]                  },
        { allow: groups, operations: [ read ],  groups: ["Viewers"]                            },
        { allow: public, operations: [ read ]                                                  }
    ])
    @key (
        name: "Edges_by_predicate", 
        fields: ["predicate", "createdAt"]
        queryField: "edgesByPredicate"
    )
    @key ( 
        name: "Objects_by_subject", 
        fields: ["node_subject", "node_object"] 
    ) 
    @key ( 
        name: "Subjects_by_object", 
        fields: ["node_object", "node_subject"] 
    ) 
{
    id              : ID!
    node_subject    : ID! 
    node_object     : ID! 
    createdAt       : AWSDateTime!
    predicate       : Predicate!
    subject         : Node!         @connection (fields: ["node_subject"])
    object          : Node!         @connection (fields: ["node_object"])
    owner           : String
    weight          : Int
}
